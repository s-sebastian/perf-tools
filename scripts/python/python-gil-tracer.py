# perf script event handlers, generated by perf script -g python
# Licensed under the terms of the GNU GPL License version 2

# The common_* event handler fields are the most useful fields common to
# all events.  They don't necessarily correspond to the 'common_*' fields
# in the format files.  Those fields not available as handler params can
# be retrieved using Python functions of the form common_*(context).
# See the perf-script-python Documentation for the list of available functions.

from __future__ import print_function

import argparse
import json
import os
import sys

sys.path.append(
    os.environ["PERF_EXEC_PATH"] + "/scripts/python/Perf-Trace-Util/lib/Perf/Trace"
)

from perf_trace_context import *
from Core import *
from Util import nsecs

from viztracer import __version__


NSECS_PER_MS = 1e3

trace_events = []
ppids = {}
last_run_time = {}
last_sleep_time = {}
takes_gil = {}


def parse_args():
    desc = """
    Python GIL tracer.
    """

    parser = argparse.ArgumentParser(description=desc)

    parser.add_argument(
        "-o",
        "--output",
        type=argparse.FileType("w"),
        default="gil_trace.json",
        help="Output filename. Default %(default)s",
    )

    parser.add_argument(
        "-r",
        "--running",
        action="store_true",
        help="Show running phase. Default: %(default)s",
    )

    args = parser.parse_args()

    return args


def msecs(sec, nsec):
    return nsecs(sec, nsec) / NSECS_PER_MS


# def trace_begin():
#     print("in trace_begin")


def trace_end():
    json.dump(
        {
            "traceEvents": trace_events,
            "viztracer_metadata": {"overflow": False, "version": __version__},
        },
        args.output,
    )


def sched__sched_process_fork(
    event_name,
    context,
    common_cpu,
    common_secs,
    common_nsecs,
    common_pid,
    common_comm,
    common_callchain,
    parent_comm,
    parent_pid,
    child_comm,
    child_pid,
    perf_sample_dict,
):
    ppids[child_pid] = parent_pid


def sched__sched_switch(
    event_name,
    context,
    common_cpu,
    common_secs,
    common_nsecs,
    common_pid,
    common_comm,
    common_callchain,
    prev_comm,
    prev_pid,
    prev_prio,
    prev_state,
    next_comm,
    next_pid,
    next_prio,
    perf_sample_dict,
):
    ts = msecs(common_secs, common_nsecs)
    prev_state_flag = flag_str(event_name, "prev_state", prev_state)

    if prev_state_flag == "" or prev_state_flag == "R":
        last_sleep_time[prev_pid] = ts
        return

    if prev_pid not in last_run_time:
        return

    ts2 = last_run_time.pop(prev_pid)
    dur = ts - ts2

    for node in common_callchain:
        if "sym" in node and node["sym"]["name"] == "take_gil":
            takes_gil[prev_pid] = True
            break

    if args.running:
        trace_events.append(
            {
                "name": "R",
                "cat": "process state",
                "ph": "X",
                "ts": ts2,
                "pid": ppids.get(common_pid, common_pid),
                "tid": common_pid,
                "dur": dur,
            }
        )

    last_sleep_time[prev_pid] = ts


def sched__sched_wakeup_new(
    event_name,
    context,
    common_cpu,
    common_secs,
    common_nsecs,
    common_pid,
    common_comm,
    common_callchain,
    comm,
    pid,
    prio,
    target_cpu,
    perf_sample_dict,
):
    ts = msecs(common_secs, common_nsecs)
    last_run_time[pid] = ts


def sched__sched_wakeup(
    event_name,
    context,
    common_cpu,
    common_secs,
    common_nsecs,
    common_pid,
    common_comm,
    common_callchain,
    comm,
    pid,
    prio,
    target_cpu,
    perf_sample_dict,
):
    ts = msecs(common_secs, common_nsecs)

    if pid not in last_sleep_time:
        last_run_time[pid] = ts
        return

    name = "S"
    cname = "bad"

    if takes_gil.pop(pid, False):
        name = "S(GIL)"
        cname = "terrible"

    ts2 = last_sleep_time.pop(pid)
    dur = ts - ts2

    trace_events.append(
        {
            "name": name,
            "cat": "process state",
            "ph": "X",
            "ts": ts2,
            "pid": ppids.get(pid, pid),
            "tid": pid,
            "dur": dur,
            "cname": cname,
        }
    )

    last_run_time[pid] = ts


def print_header(event_name, cpu, secs, nsecs, pid, comm):
    print(
        "%-20s %5u %05u.%09u %8u %-20s " % (event_name, cpu, secs, nsecs, pid, comm),
        end="",
    )


if __name__ == "__main__":
    args = parse_args()
